/* eslint-disable react-hooks/exhaustive-deps */
/* eslint-disable no-shadow */
import PropTypes from 'prop-types';
import { initializeApp } from 'firebase/app';
import { getFunctions, httpsCallable } from 'firebase/functions';
import { useMemo, useState, useEffect, useReducer, useCallback } from 'react';
import {
  ref,
  listAll,
  getStorage,
  deleteObject,
  getDownloadURL,
  uploadBytesResumable,
} from 'firebase/storage';
import {
  getAuth,
  signOut,
  updateProfile,
  onAuthStateChanged,
  sendEmailVerification,
  sendPasswordResetEmail,
  signInWithEmailAndPassword,
  createUserWithEmailAndPassword,
} from 'firebase/auth';
import {
  doc,
  where,
  query,
  setDoc,
  getDoc,
  getDocs,
  increment,
  deleteDoc,
  updateDoc,
  onSnapshot,
  writeBatch,
  collection,
  getFirestore,
  collectionGroup,
  getCountFromServer,
} from 'firebase/firestore';

import { FIREBASE_API } from 'src/config-global';
import {
  DEFAULT_MENUS,
  DEFAULT_MEALS,
  DEFAULT_LABELS,
} from 'src/_mock/business-profile-default-values';

import { AuthContext } from './auth-context';

// ----------------------------------------------------------------------

// NOTE:
// We only build demo at basic level.
// Customer will need to do some extra handling yourself if you want to extend the logic and other features...

// ----------------------------------------------------------------------

const THIS_MONTH = new Date().getMonth();
const THIS_YEAR = new Date().getFullYear();

const initialState = {
  user: null,
  loading: true,
};

const reducer = (state, action) => {
  if (action.type === 'INITIAL') {
    return {
      loading: false,
      user: action.payload.user,
    };
  }
  return state;
};

const firebaseApp = initializeApp(FIREBASE_API);
const AUTH = getAuth(firebaseApp);
const DB = getFirestore(firebaseApp);
const STORAGE = getStorage(firebaseApp);
const FUNCTIONS = getFunctions(firebaseApp);

AuthProvider.propTypes = {
  children: PropTypes.node,
};

const BUCKET = 'menu-app-b268b';

export function AuthProvider({ children }) {
  const [state, dispatch] = useReducer(reducer, initialState);
  const [orderSnapShot, setOrderSnapShot] = useState({});
  const [activeOrders, setActiveOrders] = useState([]);
  const [menuSections, setMenuSections] = useState([]);
  const [staff, setStaff] = useState({});

  const checkAuthenticated = state.user?.emailVerified ? 'authenticated' : 'unauthenticated';
  const status = state.loading ? 'loading' : checkAuthenticated;

  const initialize = useCallback(() => {
    try {
      onAuthStateChanged(AUTH, async (user) => {
        if (user) {
          if (user.emailVerified) {
            const userProfile = doc(DB, 'users', user.uid);
            const docSnap = await getDoc(userProfile);
            const profile = docSnap.data();

            // create user profile (first time)
            if (!profile) {
              await setDoc(userProfile, { uid: user.uid, email: user.email, role: 'user' });
            }

            // update user last login time.
            await updateDoc(userProfile, { lastLogin: new Date() });

            dispatch({
              type: 'INITIAL',
              payload: {
                user: {
                  ...user,
                  ...profile,
                  id: user.uid,
                },
              },
            });
          } else {
            dispatch({
              type: 'INITIAL',
              payload: {
                user: null,
              },
            });
          }
        } else {
          dispatch({
            type: 'INITIAL',
            payload: {
              user: null,
            },
          });
        }
      });
    } catch (error) {
      console.error(error);
      dispatch({
        type: 'INITIAL',
        payload: {
          user: null,
        },
      });
    }
  }, []);
  useEffect(() => {
    initialize();
  }, [initialize]);
  // LOGIN
  const login = useCallback(async (email, password) => {
    await signInWithEmailAndPassword(AUTH, email, password);
  }, []);
  // UPDATE USER PROFILE
  const updateUserProfile = useCallback(async (displayName) => {
    const userProfile = await updateProfile(AUTH.currentUser, { displayName });
    return userProfile;
  }, []);
  // REGISTER
  const register = useCallback(async (email, password, displayName) => {
    const newUser = await createUserWithEmailAndPassword(AUTH, email, password);
    await sendEmailVerification(newUser.user);

    const userProfile = doc(collection(DB, 'users'), newUser.user?.uid);

    await setDoc(userProfile, {
      uid: newUser.user?.uid,
      displayName,
      email,
      role: 'owner',
      password,
      isActive: true,
      lastLogin: new Date(),
    });

    return newUser.user?.uid;
  }, []);
  // LOGOUT
  const logout = useCallback(async () => {
    await signOut(AUTH);
  }, []);
  // FORGOT PASSWORD
  const forgotPassword = useCallback(async (email) => {
    if (!email.endsWith('@kojak-group.com')) throw new Error('Email Domain Not Allowed !!');
    await sendPasswordResetEmail(AUTH, email);
  }, []);
  const updateUserAccessPaths = useCallback(async (userID, allowedPaths) => {
    const docRef = doc(DB, `/users/${userID}`);
    await updateDoc(docRef, { allowedPaths });
  }, []);
  const fsGetUser = useCallback(async (userID) => {
    try {
      const docRef = doc(DB, `/users/${userID}`);
      const docSnapshot = await getDoc(docRef);
      if (!docSnapshot.data()) throw Error('No User Was Returned !!');
      return docSnapshot.data();
    } catch (error) {
      throw error;
    }
  }, []);
  const fsGetUsers = useCallback(async () => {
    const docRef = collection(DB, '/users');
    const queryRef = query(docRef);
    const querySnapshot = await getDocs(queryRef);
    const documents = [];
    querySnapshot.forEach((element) => {
      documents.push(element.data());
    });

    return documents.filter((user) => user.email !== 'hussam@hotmail.co.uk');
  }, []);
  // ------------------------- Firebase Functions -----------------
  const fbTranslate = httpsCallable(FUNCTIONS, 'fbTranslateSectionTitle');
  const fbTranslateMeal = httpsCallable(FUNCTIONS, 'fbTranslateMeal');
  const fbTranslateBranchDesc = httpsCallable(FUNCTIONS, 'fbTranslateBranchDesc');
  // ------------------------ Image Handiling ----------------------
  const fsGetImgDownloadUrl = useCallback(async (bucketPath, imgID) => {
    // eslint-disable-next-line no-useless-catch
    try {
      return await getDownloadURL(ref(STORAGE, `gs://${bucketPath}${imgID}`));
    } catch (error) {
      throw error;
    }
  }, []);
  const fsGetFolderImages = useCallback(async (bucket, folderID) => {
    const listRef = ref(STORAGE, `gs://${bucket}/${folderID}`);
    const imagesList = await listAll(listRef);
    const imagesUrl = await Promise.all(
      imagesList.items.map(async (imageRef) => getDownloadURL(ref(STORAGE, imageRef)))
    );
    const thumbnail = imagesUrl.filter((url) => url.includes('200x200'));
    const largeImage = imagesUrl.filter((url) => url.includes('1920x1080'));
    return [thumbnail, largeImage];
  }, []);
  const fsDeleteImage = useCallback(async (bucketPath, imgID) => {
    const storageRef = ref(STORAGE, `gs://${bucketPath}${imgID}`);
    deleteObject(storageRef)
      .then(() => {
        console.log('Image deleted successfully');
      })
      .catch((error) => {
        console.error('Error deleting image:', error);
      });
  }, []);
  const fsUploadMultipleImages = useCallback(async (bucketPath, image) => {
    const storageRef = ref(STORAGE, `gs://${bucketPath}`);

    const uploadPromises = new Promise((resolve, reject) => {
      const imageRef = ref(storageRef, image.path);
      const uploadTask = uploadBytesResumable(imageRef, image);

      uploadTask.on(
        'state_changed',
        (snapshot) => {
          const percent = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
          // console.log(`${percent}% done`);
        },
        (error) => {
          reject(error);
        },
        () => {
          resolve();
        }
      );
    });

    try {
      // await Promise.all(uploadPromises);
      return uploadPromises;
    } catch (error) {
      // Handle errors during uploads
      console.error('Upload error:', error);
      throw error;
    }
  }, []);
  // ----------------------- Business Profile -------------------
  const fsCreateBusinessProfile = useCallback(
    async (data) => {
      try {
        // 1- REGISTER OWNER
        const { email, password, firstName, lastName, ...businessProfileInfo } = data;
        const ownerID = await register?.(email, password, firstName, lastName);

        // const ownerID = '0Okdx50wpUUGXpDq9IKrSFaon7w1';

        // 2- CREATE BUSINESS PROFILE
        const newDocRef = doc(collection(DB, `businessProfiles`));
        await setDoc(newDocRef, {
          ...businessProfileInfo,
          docID: newDocRef.id,
          ownerID,
          users: [],
          isActive: true,
          createdOn: new Date(),
        });

        // const businessProfileID = newDocRef.id;
        const businessProfileID = 'xvwa709NdOhNNijWICp5';
      } catch (error) {
        console.log(error);
      }
    },
    [state]
  );
  const createDefaults = useCallback(async (businessProfileID) => {
    const RUN = false;

    // 1- ADD MEAL LABELS
    const mealLabels =
      !RUN &&
      (await Promise.all(
        DEFAULT_LABELS.map(async (label) => ({
          id: await fsAddNewMealLabel(label, businessProfileID),
          label,
        }))
      ));

    // 2- ADD MEALS
    const meals =
      !RUN &&
      (await Promise.all(
        DEFAULT_MEALS(businessProfileID)
          .splice(0, 3)
          .map(async (meal, index) => {
            const modifiedMeal = {
              ...meal,
              mealLabels: meal.mealLabels.map(
                (label) => mealLabels.find((mealLabel) => mealLabel.label === label).id
              ),
            };
            const mealID = await fsAddNewMeal(modifiedMeal, businessProfileID);

            const sourceFileName = `meal_${index + 1}`; // Name of the file to copy
            const destinationFileName = `${mealID}`; // Name for the copied file

            const sourceBucket = ref(STORAGE, `gs://menu-app-b268b/_mock/meals`);
            const destinationBucket = ref(
              STORAGE,
              `gs://menu-app-b268b/${businessProfileID}/meals`
            );

            await Promise.all(
              ['_200x200.webp', '_800x800.webp'].map(async (imageSize) => {
                // Get a reference to the source file
                const sourceFile = sourceBucket.file(`${sourceFileName}${imageSize}`);

                // Get a reference to the destination file
                const destinationFile = destinationBucket.file(
                  `${destinationFileName}${imageSize}`
                );

                // Copy the file from source to destination
                await sourceFile.copy(destinationFile);
              })
            );

            return {
              id: mealID,
              meal,
            };
          })
      ));

    // 3- ADD MENUS
    const menus =
      RUN &&
      (await Promise.all(
        DEFAULT_MENUS(businessProfileID).map(async (menu) => ({
          id: await fsAddNewMenu(menu, businessProfileID),
          menu,
        }))
      ));

    console.log(menus);
  }, []);
  // ----------------------- Tables -----------------------------
  const fsUpdateTable = useCallback(async (docPath, payload) => {
    const docRef = doc(DB, docPath);
    await updateDoc(docRef, payload);
  }, []);
  const fsAddBatchTablesToBranch = useCallback(
    async (branchID) => {
      const MAX_ALLOWED_USER_TABLES = 5;
      const batch = writeBatch(DB);

      for (let index = 0; index <= MAX_ALLOWED_USER_TABLES; index += 1) {
        const newDocRef = doc(
          collection(DB, `/users/${state.user.id}/branches/${branchID}/tables`)
        );
        batch.set(newDocRef, {
          docID: newDocRef.id,
          userID: state.user.id,
          branchID,
          isActive: true,
          title: index === 0 ? `Menu View only` : `Table ${index}`,
          note:
            index === 0
              ? `This virtual table offers a QR-Menu that exclusively displays your menu. You can utilize this QR menu by showcasing it on your restaurant's front door, allowing customers to easily view your offerings. `
              : '',
          index,
        });
      }

      await batch.commit();
    },
    [state]
  );
  const fsGetTableInfo = useCallback(async (userID, branchID, tableID) => {
    try {
      const docRef = query(
        collectionGroup(DB, 'tables'),
        where('userID', '==', userID),
        where('branchID', '==', branchID),
        where('docID', '==', tableID)
      );
      const querySnapshot = await getDocs(docRef);
      const dataArr = [];
      querySnapshot.forEach((doc) => dataArr.push(doc.data()));
      return dataArr[0];
    } catch (error) {
      throw error;
    }
  }, []);
  const fsChangeMenuForAllTables = useCallback(
    async (branchID, menuID) => {
      const docsRef = query(
        collectionGroup(DB, 'tables'),
        where('userID', '==', state.user.id),
        where('branchID', '==', branchID)
      );
      const snapshot = await getDocs(docsRef);

      const batch = writeBatch(DB);
      snapshot.docs.forEach((doc) => {
        batch.update(doc.ref, { menuID });
      });

      await batch.commit();
    },
    [state]
  );
  const fsGetBranchTables = useCallback(
    async (branchID, userID = state.user.id) => {
      const docRef = query(
        collectionGroup(DB, 'tables'),
        where('userID', '==', userID),
        where('branchID', '==', branchID)
      );
      const querySnapshot = await getDocs(docRef);
      const dataArr = [];
      querySnapshot.forEach((doc) => dataArr.push(doc.data()));

      return dataArr;
    },
    [state]
  );
  const fsUpdateBranchTable = useCallback(
    async (branchID, tableID, value) => {
      const docRef = doc(DB, `/users/${state.user.id}/branches/${branchID}/tables/${tableID}`);
      await updateDoc(docRef, value);
    },
    [state]
  );
  const fsGetBranchTablesCount = useCallback(
    async (branchID) => {
      const query_ = query(
        collectionGroup(DB, 'tables'),
        where('userID', '==', state.user.id),
        where('branchID', '==', branchID)
      );
      const snapshot = await getCountFromServer(query_);
      return snapshot.data().count;
    },
    [state]
  );
  // ------------------------ Orders -----------------------------
  const fsGetTableOrdersByPeriod = useCallback(
    async (tableID, branchID, targetMonth = THIS_MONTH, targetYear = THIS_YEAR) => {
      const startDate = new Date(Date.UTC(targetYear, targetMonth, 1)); // Start of the month
      const endDate = new Date(Date.UTC(targetYear, targetMonth + 1, 0)); // End of the month

      const docRef = query(
        collectionGroup(DB, 'orders'),
        where('userID', '==', state.user.id),
        where('branchID', '==', branchID),
        where('tableID', '==', tableID),
        where('initiationTime', '>=', startDate),
        where('initiationTime', '<=', endDate)
      );
      const querySnapshot = await getDocs(docRef);
      const dataArr = [];
      querySnapshot.forEach((doc) => dataArr.push(doc.data()));
      return dataArr;
    },
    [state]
  );
  // ----------------------- Branches ----------------------------
  const fsGetAllBranches = useCallback(async () => {
    const docRef = query(
      collectionGroup(DB, 'branches'),
      where('userID', '==', state.user.id),
      where('isDeleted', '==', false)
    );
    const querySnapshot = await getDocs(docRef);
    const dataArr = [];
    const asyncOperations = [];

    querySnapshot.forEach((element) => {
      const asyncOperation = async () => {
        const bucket = `menu-app-b268b/${state.user.id}/branches/${element.data().docID}/`;
        const imgUrl = await fsGetImgDownloadUrl(bucket, `cover_200x200.webp`);

        dataArr.push({ ...element.data(), imgUrl });
      };
      asyncOperations.push(asyncOperation());
    });

    await Promise.all(asyncOperations);

    return dataArr;
  }, [state]);
  const fsGetBranch = useCallback(
    async (branchID, userID = state.user.id) => {
      try {
        const docRef = doc(DB, `/users/${userID}/branches/${branchID}/`);
        const docSnap = await getDoc(docRef);

        if (docSnap.data().translation === '') throw new Error('No Translation Found !!');

        const bucketPath = `${BUCKET}/${userID}/branches/${branchID}/`;
        const imgUrl = await fsGetImgDownloadUrl(bucketPath, 'cover_800x800.webp');

        return {
          ...docSnap.data(),
          lastUpdatedAt: new Date(docSnap.data().lastUpdatedAt.seconds * 1000).toDateString(),
          cover: `${imgUrl}?${Date.now()}`,
        };
      } catch (error) {
        throw error;
      }
    },
    [state]
  );
  const fsAddNewBranch = useCallback(
    async (branchData) => {
      const newDocRef = doc(collection(DB, `users/${state.user.id}/branches/`));
      const { cover: imageFile, ...documentData } = branchData;
      await setDoc(newDocRef, {
        ...documentData,
        docID: newDocRef.id,
        userID: state.user.id,
        isDeleted: false,
        lastUpdatedBy: state.user.id,
        lastUpdatedAt: new Date(),
      });

      await fsAddBatchTablesToBranch(newDocRef.id);

      fbTranslateBranchDesc({
        branchRef: newDocRef.path,
        text: { description: documentData.description },
        userID: state.user.id,
      });

      const storageRef = ref(
        STORAGE,
        `gs://menu-app-b268b/${state.user.id}/branches/${newDocRef.id}/`
      );

      if (imageFile) {
        console.log(imageFile);
        const imageRef = ref(storageRef, 'cover.jpg');
        const uploadTask = uploadBytesResumable(imageRef, imageFile);
        uploadTask.on(
          'state_changed',
          (snapshot) => {
            console.log(snapshot);
          },
          (error) => {
            console.log(error);
          },
          () => {
            console.log('UPLOADED');
          }
        );
      }
    },
    [state]
  );
  const fsUpdateBranch = useCallback(
    async (branchData, shouldUpdateCover = false) => {
      const docRef = doc(DB, `/users/${state.user.id}/branches/${branchData.docID}`);
      const { cover: imageFile, ...documentData } = branchData;
      await updateDoc(docRef, {
        ...documentData,
        lastUpdatedBy: state.user.id,
        lastUpdatedAt: new Date(),
      });

      if (branchData.translation === '')
        fbTranslateBranchDesc({
          branchRef: docRef.path,
          text: { description: documentData.description },
          userID: state.user.id,
        });

      if (shouldUpdateCover) {
        const storageRef = ref(
          STORAGE,
          `gs://menu-app-b268b/${state.user.id}/branches/${branchData.docID}/`
        );

        const files = await listAll(storageRef);
        files.items.forEach((file) => {
          deleteObject(file);
        });

        const imageRef = ref(storageRef, 'cover.jpg');
        const uploadTask = uploadBytesResumable(imageRef, imageFile);
        uploadTask.on(
          'state_changed',
          (snapshot) => {},
          (error) => {},
          () => {}
        );
      }
    },
    [state]
  );
  const fsDeleteBranch = useCallback(
    async (branchID) => {
      const docRef = doc(DB, `/users/${state.user.id}/branches/${branchID}`);
      await deleteDoc(docRef);

      const storageRef = ref(STORAGE, `gs://menu-app-b268b/${state.user.id}/branches/${branchID}/`);
      const files = await listAll(storageRef);
      files.items.forEach((file) => {
        deleteObject(file);
      });
    },
    [state]
  );
  // ------------------------- Menu --------------------------------
  const fsGetMenu = useCallback(
    async (menuID, userID = state.user.id) => {
      const docRef = doc(DB, `/users/${userID}/menus/${menuID}/`);
      const docSnap = await getDoc(docRef);
      return docSnap.data();
    },
    [state]
  );
  const fsGetAllMenus = useCallback(async () => {
    const docRef = query(
      collectionGroup(DB, 'menus'),
      where('userID', '==', state.user.id),
      where('isDeleted', '==', false)
    );

    const dataArr = [];
    const querySnapshot = await getDocs(docRef);
    querySnapshot.forEach((doc) =>
      dataArr.push({
        ...doc.data(),
        lastUpdatedAt: `${new Date(
          doc.data().lastUpdatedAt.seconds * 1000
        ).toDateString()} | ${new Date(
          doc.data().lastUpdatedAt.seconds * 1000
        ).toLocaleTimeString()}`,
      })
    );
    return dataArr;
  }, [state]);
  const fsAddNewMenu = useCallback(
    async (data, businessProfileID = state.user.businessProfileID) => {
      const newDocRef = doc(collection(DB, `/businessProfiles/${businessProfileID}/menus/`));
      setDoc(newDocRef, {
        ...data,
        docID: newDocRef.id,
        businessProfileID,
        isActive: true,
        isDeleted: false,
        lastUpdatedAt: new Date(),
      });
      return newDocRef.id;
    },
    [state]
  );
  const fsUpdateMenu = useCallback(
    async (data) => {
      const docRef = doc(DB, `/users/${state.user.id}/menus/${data.docID}`);
      await updateDoc(docRef, {
        ...data,
        lastUpdatedAt: new Date(),
        lastUpdateBy: state.user.id,
      });
    },
    [state]
  );
  const fsDeleteMenu = useCallback(
    async (docID) => {
      const docRef = doc(DB, `/users/${state.user.id}/menus/${docID}`);
      await deleteDoc(docRef);
    },
    [state]
  );
  // --------------------- Menu Sections --------------------------
  const fsAddSection = useCallback(
    async (menuID, title, order) => {
      const userID = state.user.id;
      const newDocRef = doc(collection(DB, `/users/${userID}/menus/${menuID}/sections`));
      await setDoc(newDocRef, {
        docID: newDocRef.id,
        menuID,
        userID,
        title,
        meals: [],
        order,
        isActive: false,
      });

      fbTranslate({
        sectionRef: `/users/${userID}/menus/${menuID}/sections/${newDocRef.id}`,
        text: title,
      });

      return newDocRef.id;
    },
    [state]
  );
  const fsGetSections = useCallback(
    async (menuID, userID = state.user.id) => {
      const docRef = query(
        collectionGroup(DB, 'sections'),
        where('userID', '==', userID),
        where('menuID', '==', menuID)
      );

      const unsubscribe = onSnapshot(docRef, (querySnapshot) => {
        const sectionsArray = [];
        querySnapshot.forEach((doc) => sectionsArray.push(doc.data()));
        setMenuSections(sectionsArray);
      });

      return unsubscribe;
    },
    [state]
  );
  const fsDeleteSection = useCallback(
    async (menuID, sectionID, orderValue) => {
      const docRef = doc(DB, `/users/${state.user.id}/menus/${menuID}/sections/${sectionID}`);
      await deleteDoc(docRef);

      // get all sections that order index is above the one is being deleted and reduce it
      const docsRef = query(
        collectionGroup(DB, 'sections'),
        where('userID', '==', state.user.id),
        where('menuID', '==', menuID),
        where('order', '>', orderValue)
      );
      const snapshot = await getDocs(docsRef);

      // Update sections order
      const batch = writeBatch(DB);
      snapshot.docs.forEach((doc) => {
        batch.update(doc.ref, { order: increment(-1) });
      });

      await batch.commit();
    },
    [state]
  );
  const fsUpdateSection = useCallback(
    async (menuID, sectionID, payload, userID = state.user.id) => {
      const docRef = doc(DB, `/users/${userID}/menus/${menuID}/sections/${sectionID}/`);
      await updateDoc(docRef, payload);
    },
    [state]
  );
  const fsUpdateSectionTitle = useCallback(
    async (menuID, sectionID, payload) => {
      console.log({ menuID, sectionID, payload });
      const docRef = doc(DB, `/users/${state.user.id}/menus/${menuID}/sections/${sectionID}/`);
      await updateDoc(docRef, payload);

      fbTranslate({
        sectionRef: `/users/${state.user.id}/menus/${menuID}/sections/${docRef.id}`,
        text: payload.title,
      });
    },
    [state]
  );
  const fsGetSection = useCallback(
    async (menuID, sectionID) => {
      try {
        const docRef = doc(DB, `/users/${state.user.id}/menus/${menuID}/sections/${sectionID}`);
        const docSnap = await getDoc(docRef);

        if (docSnap.data().translation === '') throw Error('No Translation Available !!');

        return docSnap.data();
      } catch (error) {
        throw error;
      }
    },
    [state]
  );
  const fsUpdateSectionsOrder = useCallback(
    async (
      menuID,
      clickedSectionID,
      clickedSectionOrder,
      affectedSectionID,
      affectedSectionNewOrder
    ) => {
      try {
        const batch = writeBatch(DB);
        const docRef = doc(
          DB,
          `/users/${state.user.id}/menus/${menuID}/sections/${clickedSectionID}/`
        );
        batch.update(docRef, { order: clickedSectionOrder });

        const affectedSectionDocRef = doc(
          DB,
          `/users/${state.user.id}/menus/${menuID}/sections/${affectedSectionID}/`
        );
        batch.update(affectedSectionDocRef, { order: affectedSectionNewOrder });

        await batch.commit();
      } catch (error) {
        throw error;
      }
    },
    [state]
  );
  const fsGetSectionMeals = useCallback(async (userID, sectionMeals, size = '800x800') => {
    const docRef = query(
      collectionGroup(DB, 'meals'),
      where('userID', '==', userID),
      where('docID', 'in', sectionMeals)
      // where('isActive', '==', true)
    );
    const querySnapshot = await getDocs(docRef);
    const dataArr = [];
    const asyncOperations = [];

    querySnapshot.forEach((element) => {
      const asyncOperation = async () => {
        const bucket = `menu-app-b268b/${userID}/meals/${element.data().docID}/`;
        const cover = await fsGetImgDownloadUrl(bucket, `${element.data().docID}_${size}.webp`);

        dataArr.push({ ...element.data(), cover });
      };
      asyncOperations.push(asyncOperation());
    });

    await Promise.all(asyncOperations);

    return dataArr;
  }, []);
  const fsEmptyMenuSelectedMeals = useCallback(
    async (menuID) => {
      const docRef = doc(DB, `/users/${state.user.id}/menus/${menuID}/`);
      await updateDoc(docRef, { meals: [] });
    },
    [state]
  );
  const fsDeleteAllSections = useCallback(
    async (menuID) => {
      const docRef = query(
        collectionGroup(DB, 'sections'),
        where('userID', '==', state.user.id),
        where('menuID', '==', menuID)
      );
      const snapshot = await getDocs(docRef);

      const batch = writeBatch(DB);
      snapshot.docs.forEach((doc) => {
        batch.delete(doc.ref);
      });

      await batch.commit();
    },
    [state]
  );
  const deleteMenu = useCallback(
    async (menuID) => {
      const docRef = doc(DB, `/users/${state.user.id}/menus/`, menuID);
      await deleteDoc(docRef);
    },
    [state]
  );
  // ------------------------- Meals --------------------------------
  const fsAddNewMeal = useCallback(
    async (mealInfo, businessProfileID = state.user.businessProfileID) => {
      const date = new Date();
      const dateTime = date.toDateString();

      const newDocRef = doc(collection(DB, `/businessProfiles/${businessProfileID}/meals/`));

      const { imageFile, cover, ...mealData } = mealInfo;

      await setDoc(newDocRef, {
        ...mealData,
        docID: newDocRef.id,
        lastUpdatedAt: dateTime,
        businessProfileID,
        isDeleted: false,
      });

      await fbTranslateMeal({
        mealRef: `/businessProfiles/${businessProfileID}/meals/${newDocRef.id}`,
        text: { title: mealInfo.title, desc: mealInfo.description },
        businessProfileID,
      });

      const storageRef = ref(
        STORAGE,
        `gs://menu-app-b268b/${businessProfileID}/meals/${newDocRef.id}/`
      );

      const fileExtension = imageFile.name.substring(imageFile.name.lastIndexOf('.') + 1);

      if (imageFile) {
        const imageRef = ref(storageRef, `${newDocRef.id}.${fileExtension}`);
        const uploadTask = uploadBytesResumable(imageRef, imageFile);
        uploadTask.on(
          'state_changed',
          (snapshot) => {},
          (error) => {},
          () => {}
        );
      }
      return newDocRef.id;
    },
    [state]
  );
  const fsUpdateMeal = useCallback(
    async (payload, imageIsDirty) => {
      try {
        const { imageFile, cover, ...mealData } = payload;
        const docRef = doc(DB, `/users/${state.user.id}/meals/${payload.docID}/`);
        await updateDoc(docRef, mealData);

        const storageRef = ref(
          STORAGE,
          `gs://menu-app-b268b/${state.user.id}/meals/${payload.docID}/`
        );

        if (imageFile && imageIsDirty) {
          const fileExtension = imageFile.name.substring(imageFile.name.lastIndexOf('.') + 1);
          const imageRef = ref(storageRef, `${payload.docID}.${fileExtension}`);

          const uploadTask = uploadBytesResumable(imageRef, imageFile);
          uploadTask.on(
            'state_changed',
            (snapshot) => {},
            (error) => {},
            () => {}
          );
        }

        if (payload.translation === '' && payload.translationEdited === '')
          console.log('TRANSLATE');
        fbTranslateMeal({
          mealRef: `/users/${state.user.id}/meals/${payload.docID}`,
          text: { title: payload.title, desc: payload.description },
          userID: state.user.id,
        });
      } catch (error) {
        console.log(error);
        throw error;
      }
    },
    [state]
  );
  const fsGetAllMeals = useCallback(async () => {
    const docRef = query(collectionGroup(DB, 'meals'), where('userID', '==', state.user.id));
    const querySnapshot = await getDocs(docRef);
    const dataArr = [];
    const asyncOperations = [];

    querySnapshot.forEach((element) => {
      const asyncOperation = async () => {
        const bucket = `menu-app-b268b/${state.user.id}/meals/${element.data().docID}/`;
        try {
          const cover = await fsGetImgDownloadUrl(bucket, `${element.data().docID}_200x200.webp`);
          dataArr.push({ ...element.data(), cover });
        } catch (error) {
          // Handle the case where cover is not available
          throw new Error(`Cover not available for meal with ID: ${element.data().docID}`);
        }
      };
      asyncOperations.push(asyncOperation());
    });
    await Promise.all(asyncOperations);

    return dataArr;
  }, [state]);
  const fsGetMeal = useCallback(
    async (mealID, size = '800x800', userID = state.user.id) => {
      try {
        const docRef = doc(DB, `/users/${userID}/meals/${mealID}/`);
        const docSnap = await getDoc(docRef);

        const bucketPath = `${BUCKET}/${userID}/meals/${mealID}/`;
        const imgUrl = await fsGetImgDownloadUrl(bucketPath, `${mealID}_${size}.webp`);

        if (docSnap.data().translation === '' || docSnap?.data()?.translation === undefined)
          throw new Error('NO Translation Found!!');

        return {
          ...docSnap.data(),
          cover: `${imgUrl}?${Date.now()}`,
        };
      } catch (error) {
        console.log(error);
        throw error;
      }
    },
    [state]
  );
  const fsDeleteMeal = useCallback(
    async (mealID) => {
      try {
        const docRef = doc(DB, `/users/${state.user.id}/meals/`, mealID);
        await deleteDoc(docRef);

        const bucketPath = `${BUCKET}/${state.user.id}/meals/${mealID}/`;
        await fsDeleteImage(bucketPath, `${mealID}_200x200.webp`);
        await fsDeleteImage(bucketPath, `${mealID}_800x800.webp`);
      } catch (error) {
        throw error;
      }
    },
    [state]
  );
  const fsGetMealLabels = useCallback(
    async (userID = state.user.id) => {
      try {
        const dataArr = [];
        const docRef = query(collectionGroup(DB, 'meal-labels'), where('userID', '==', userID));
        const querySnapshot = await getDocs(docRef);
        querySnapshot.forEach((doc) => {
          dataArr.push(doc.data());
        });
        return dataArr;
      } catch (error) {
        console.log(error);
        throw error;
      }
    },
    [state]
  );
  const fsAddNewMealLabel = useCallback(
    async (title, businessProfileID = state.user.businessProfileID) => {
      const docRef = doc(collection(DB, `/businessProfiles/${businessProfileID}/meal-labels/`));
      await setDoc(docRef, { title, isActive: true, businessProfileID, docID: docRef.id });
      return docRef.id;
    },
    [state]
  );
  const updatedAffectedMeals = useCallback(
    async (mealLabelID) => {
      const mealRef = query(
        collectionGroup(DB, 'meals'),
        where('userID', '==', state.user.id),
        where('mealLabels', 'array-contains', mealLabelID)
      );
      const querySnapshot = await getDocs(mealRef);
      const asyncOperations = [];
      const affectedMealsIDs = [];

      querySnapshot.forEach((mealDoc) => {
        const asyncOperation = async () => {
          const { mealLabels } = mealDoc.data();
          const updatedMealLabels = mealLabels.filter((mealID) => mealID !== mealLabelID);
          await updateDoc(mealDoc.ref, { mealLabels: [...updatedMealLabels] });
          affectedMealsIDs.push(mealDoc.data().docID);
        };
        asyncOperations.push(asyncOperation());
      });

      await Promise.all(asyncOperations);
      return affectedMealsIDs;
    },
    [state]
  );
  const fsUpdateMealLabel = useCallback(
    async (payload) => {
      try {
        const docRef = doc(DB, `/users/${state.user.id}/meal-labels/${payload.docID}/`);
        await updateDoc(docRef, payload);

        return updatedAffectedMeals(payload.docID);
      } catch (error) {
        throw error;
      }
    },
    [state]
  );
  const fsDeleteMealLabel = useCallback(
    async (mealLabelID) => {
      try {
        const labelRef = doc(DB, `/users/${state.user.id}/meal-labels/${mealLabelID}/`);
        await deleteDoc(labelRef);

        return updatedAffectedMeals(mealLabelID);
      } catch (error) {
        console.log(error);
        throw error;
      }
    },
    [state]
  );
  // -------------------------- QR Menu - Cart -----------------------------------
  const fsInitiateNewOrder = useCallback(async (payload) => {
    const { tableID, menuID, staffID, userID, branchID } = payload;

    const existingDocRef = query(
      collectionGroup(DB, 'orders'),
      where('userID', '==', userID),
      where('branchID', '==', branchID),
      where('tableID', '==', tableID),
      where('isPaid', '==', false),
      where('isCanceled', '==', false)
    );
    const querySnapshot = await getDocs(existingDocRef);
    // Check if the query snapshot is empty
    if (querySnapshot.empty) {
      const docRef = doc(collection(DB, `/users/${userID}/branches/${branchID}/orders`));
      await setDoc(docRef, {
        docID: docRef.id,
        userID,
        branchID,
        tableID,
        menuID,
        staffID,
        cart: [],
        status: [],
        isInKitchen: [],
        isReadyToServe: [],
        isCanceled: false,
        isPaid: false,
        updateCount: 0,
        initiationTime: new Date(),
        lastUpdate: new Date(),
        sessionExpiryTime: new Date().getTime() + 45 * 60000,
      });
      return docRef.id;
    }
    return null;
  }, []);
  const fsOrderSnapshot = useCallback(async (payload) => {
    const { userID, branchID, tableID, menuID } = payload;

    await fsInitiateNewOrder({
      initiatedBy: 'customer',
      tableID,
      menuID,
      staffID: '',
      userID,
      branchID,
    });

    const docRef = query(
      collectionGroup(DB, 'orders'),
      where('userID', '==', userID),
      where('branchID', '==', branchID),
      where('tableID', '==', tableID),
      where('isPaid', '==', false),
      where('isCanceled', '==', false)
    );

    const unsubscribe = onSnapshot(docRef, (querySnapshot) => {
      querySnapshot.forEach((doc) => {
        setOrderSnapShot(doc.data());
      });
    });

    return unsubscribe;
  }, []);
  const fsGetActiveOrdersSnapshot = useCallback(async (userID, branchID) => {
    const docRef = query(
      collectionGroup(DB, 'orders'),
      where('userID', '==', userID),
      where('branchID', '==', branchID),
      where('isPaid', '==', false),
      where('isCanceled', '==', false)
    );

    const unsubscribe = onSnapshot(docRef, (querySnapshot) => {
      const tablesArray = [];
      querySnapshot.forEach((doc) => {
        if (doc.exists()) {
          tablesArray.push(doc.data());
        }
      });
      setActiveOrders(tablesArray);
    });

    return unsubscribe;
  }, []);
  const fsUpdateCart = useCallback(async (payload) => {
    const { orderID, userID, branchID, cart } = payload;
    const docRef = doc(DB, `/users/${userID}/branches/${branchID}/orders/${orderID}`);

    updateDoc(docRef, { cart });
    // if (resetStatus) updateDoc(docRef, { status: { ...status, ready: '', collected: '', kitchen: '' } });
  }, []);
  const fsConfirmCartOrder = useCallback(
    async (cart, totalBill, branchID, userID = state.user.id) => {
      const userRef = doc(DB, `/users/${userID}`);

      await updateDoc(userRef, {
        [`statisticsSummary.branches.${branchID}.income.${THIS_YEAR}.${THIS_MONTH}`]:
          increment(totalBill),
        [`statisticsSummary.branches.${branchID}.orders.${THIS_YEAR}.${THIS_MONTH}`]: increment(1),
      });

      const branchMealsOrderUsage = cart.map((cartItem) =>
        updateDoc(userRef, {
          [`statisticsSummary.branches.${branchID}.meals.${THIS_YEAR}.${THIS_MONTH}.${cartItem.mealID}`]:
            increment(1),
        })
      );

      const toResolveUser = cart.map((cartItem) =>
        updateDoc(userRef, {
          [`statisticsSummary.meals.${THIS_YEAR}.${THIS_MONTH}.${cartItem.mealID}`]: increment(1),
        })
      );

      await Promise.all([...toResolveUser, ...branchMealsOrderUsage]);
    },
    []
  );
  const fsRemoveMealFromCart = useCallback(async (payload) => {
    const { orderID, userID, branchID, cart } = payload;
    const docRef = doc(DB, `/users/${userID}/branches/${branchID}/orders/${orderID}`);
    await updateDoc(docRef, { cart });
  }, []);
  const fsUpdateOrderStatus = useCallback(async (payload) => {
    const { orderID, toUpdateFields, userID, branchID } = payload;
    const docRef = doc(DB, `/users/${userID}/branches/${branchID}/orders/${orderID}`);
    updateDoc(docRef, toUpdateFields);
  }, []);
  const fsOrderIsPaid = useCallback(async (payload) => {
    const { orderID, userID, branchID, status } = payload;
    const docRef = doc(DB, `/users/${userID}/branches/${branchID}/orders/${orderID}`);

    await updateDoc(docRef, { isPaid: true, status });
  }, []);
  const fsUpdateScanLog = useCallback(
    async (branchID, userID = state.user.id, tableID = undefined) => {
      const month = new Date().getMonth();
      const year = new Date().getFullYear();

      // TODO: SPAM Prevention : allow max # of scans coming from the same table every 5 mins
      // like maximum 20 scans can be preformed for the same table QR every 5 mins
      // allow viewing menu but dont charge scan count on restaurant

      // UPDATE statisticsSummary (User Account Level)
      const userDocRef = doc(DB, `/users/${userID}`);
      await updateDoc(userDocRef, {
        [`statisticsSummary.branches.${branchID}.scans.${year}.${month}`]: increment(1),
      });

      if (tableID) {
        const tableRef = doc(DB, `/users/${userID}/branches/${branchID}/tables/${tableID}/`);
        await updateDoc(tableRef, {
          [`statisticsSummary.scans.${year}.${month}`]: increment(1),
        });
      }
    },
    []
  );
  // ------------------ STAFF ----------------------------------
  const fsGetStaffInfo = useCallback(
    async (staffID, userID = state.user.id) => {
      try {
        const docRef = doc(DB, `/users/${userID}/staff/${staffID}/`);
        const docSnap = await getDoc(docRef);

        return docSnap.data();
      } catch (error) {
        throw error;
      }
    },
    [state]
  );
  const fsGetStaffLogin = useCallback(async (userID, staffID, passCode) => {
    try {
      const docRef = query(
        collectionGroup(DB, 'staff'),
        where('userID', '==', userID),
        where('docID', '==', staffID),
        where('passCode', '==', passCode),
        where('isActive', '==', true)
      );

      const length = await getCountFromServer(docRef);

      if (length.data().count === 0) throw Error('Nothing was returned!');

      const unsubscribe = onSnapshot(docRef, (querySnapshot) => {
        querySnapshot.forEach((doc) => {
          setStaff(doc.data());
        });
      });

      return unsubscribe;
    } catch (error) {
      throw error;
    }
  }, []);
  const fsUpdateStaffInfo = useCallback(
    async (payload, staffID, userID = state.user.id) => {
      const waiterDocRef = doc(DB, `/users/${userID}/staff/${staffID}`);
      await updateDoc(waiterDocRef, payload);
    },
    [state]
  );
  const fsGetStaffList = useCallback(
    async (branchID = '') => {
      let docRef = query(collectionGroup(DB, 'staff'), where('userID', '==', state.user.id));

      // Conditionally add branchID to where clause if provided
      if (branchID !== '') {
        docRef = query(docRef, where('branchID', '==', branchID));
      }

      const dataArr = [];
      const querySnapshot = await getDocs(docRef);
      querySnapshot.forEach((doc) => {
        dataArr.push(doc.data());
      });

      return dataArr;
    },
    [state]
  );
  const fsAddNewStaff = useCallback(
    async (payload) => {
      const newDocRef = doc(collection(DB, `/users/${state.user.id}/staff`));
      await setDoc(newDocRef, {
        ...payload,
        docID: newDocRef.id,
        userID: state.user.id,
      });
      return newDocRef.id;
    },
    [state]
  );
  const fsDeleteStaff = useCallback(
    async (staffID) => {
      const docRef = doc(DB, `/users/${state.user.id}/staff/${staffID}`);
      await updateDoc(docRef, { isLoggedIn: false });
      await deleteDoc(docRef);
    },
    [state]
  );
  // ------------------------------------------------------------

  const memoizedValue = useMemo(
    () => ({
      user: state.user,
      method: 'firebase',
      loading: status === 'loading',
      authenticated: status === 'authenticated',
      unauthenticated: status === 'unauthenticated',
      login,
      register,
      logout,
      fsGetUser,
      staff,
      setStaff,
      // ---- GENERIC ----
      fsUpdateTable,
      fsCreateBusinessProfile,
      createDefaults,
      // fsQueryDoc,
      // fsAddToDB,
      // fsRemoveFromDB,
      // Timestamp,
      // ---- FUNCTIONS ----
      fbTranslate,
      fbTranslateMeal,
      fbTranslateBranchDesc,
      // ---- STORAGE ----
      STORAGE,
      fsGetImgDownloadUrl,
      // ---- BRANCHES ----
      fsGetBranch,
      fsGetAllBranches,
      fsAddNewBranch,
      fsUpdateBranch,
      fsDeleteBranch,
      // ---- TABLES ----
      // fsAddBatchTablesToBranch,
      fsGetBranchTablesCount,
      fsGetBranchTables,
      fsUpdateBranchTable,
      fsChangeMenuForAllTables,
      fsGetTableOrdersByPeriod,
      // fsDeleteTable,
      fsGetTableInfo,
      // // ---- ORDERS ----
      fsInitiateNewOrder,
      fsOrderSnapshot,
      fsGetActiveOrdersSnapshot,
      orderSnapShot,
      activeOrders,
      // fsGetAllOrders,
      // // ---- MENU SECTIONS ----
      menuSections,
      setMenuSections,
      fsAddSection,
      fsUpdateSection,
      fsGetSections,
      fsGetSection,
      fsUpdateSectionsOrder,
      fsGetSectionMeals,
      fsDeleteSection,
      fsUpdateSectionTitle,
      // fsAddMealToMenuSelectedMeals,
      // fsRemoveMealFromMenuSelectedMeals,
      // fsDeleteAllSections,
      // fsRemoveSectionMealsFromMenuSelectedMeals,
      // fsUpdateSectionOrder,
      // fsUpdateSectionTranslation,
      // fsUpdateSectionVisibility,
      // fsUpdateSectionVisibilityDateTimeRange,
      // deleteMenu,
      // // ---- MENU ----
      fsGetAllMenus,
      fsGetMenu,
      fsAddNewMenu,
      fsUpdateMenu,
      fsDeleteMenu,
      // fsEmptyMenuSelectedMeals,
      // // ---- MEALS ----
      fsGetAllMeals,
      fsGetMeal,
      fsDeleteMeal,
      fsAddNewMeal,
      fsUpdateMeal,
      // fsDocSnapshot,
      fsGetMealLabels,
      fsAddNewMealLabel,
      fsUpdateMealLabel,
      fsDeleteMealLabel,
      // fsUpdateAllMetaTags,
      // fsUpdateMealMetaTags,
      // fsRemoveTagFromAllMeals,
      // // ---- QR Menu ----
      fsConfirmCartOrder,
      fsUpdateScanLog,
      fsUpdateCart,
      fsRemoveMealFromCart,
      // fsOrdersSnapshot,
      // fsInitiateNewOrder,
      // // ---- Waiter ----
      fsGetStaffLogin,
      fsGetStaffInfo,
      // fsWaiterTablesSnapshot,
      fsUpdateOrderStatus,
      // fsCancelOrder,
      fsOrderIsPaid,
      fsAddNewStaff,
      fsGetStaffList,
      fsUpdateStaffInfo,
      fsDeleteStaff,
      // // ---- RTD ----
      // dataSnapshotListener,
      // docSnapshot,
      // // ---- NO SIGNED IN ----
      // fsGetAllMealsOFF,
      // fsSendEmail,
      // fsSendSMS,
    }),
    [
      state.isAuthenticated,
      state.isInitialized,
      state.user,
      login,
      register,
      logout,
      fsGetUser,
      staff,
      setStaff,
      // ---- GENERIC ----
      fsUpdateTable,
      fsCreateBusinessProfile,
      createDefaults,
      // fsQueryDoc,
      // fsAddToDB,
      // fsRemoveFromDB,
      // ---- FUNCTIONS ----
      fbTranslate,
      fbTranslateMeal,
      fbTranslateBranchDesc,
      // ---- STORAGE ----
      fsGetImgDownloadUrl,
      // ---- BRANCHES ----
      fsGetBranch,
      fsGetAllBranches,
      fsAddNewBranch,
      fsUpdateBranch,
      fsDeleteBranch,
      // ---- TABLES ----
      // fsAddBatchTablesToBranch,
      // fsDeleteTable,
      fsGetBranchTablesCount,
      fsGetBranchTables,
      fsUpdateBranchTable,
      fsGetTableInfo,
      fsChangeMenuForAllTables,
      // // ---- ORDERS ----
      fsInitiateNewOrder,
      fsOrderSnapshot,
      fsGetActiveOrdersSnapshot,
      orderSnapShot,
      activeOrders,
      // fsGetAllOrders,
      fsGetTableOrdersByPeriod,
      // // ---- MENU SECTIONS ----
      fsAddSection,
      fsUpdateSection,
      fsGetSections,
      fsGetSection,
      fsUpdateSectionsOrder,
      fsGetSectionMeals,
      // fsAddMealToMenuSelectedMeals,
      // fsRemoveMealFromMenuSelectedMeals,
      // fsDeleteAllSections,
      fsDeleteSection,
      // fsRemoveSectionMealsFromMenuSelectedMeals,
      fsUpdateSectionTitle,
      // fsUpdateSectionOrder,
      // fsUpdateSectionTranslation,
      // fsUpdateSectionVisibility,
      // fsUpdateSectionVisibilityDateTimeRange,
      // deleteMenu,
      // // ---- MENU ----
      fsGetAllMenus,
      fsGetMenu,
      fsAddNewMenu,
      fsUpdateMenu,
      fsDeleteMenu,
      // fsEmptyMenuSelectedMeals,
      // fsDocSnapshot,
      // // ---- MEALS ----
      fsGetAllMeals,
      fsGetMeal,
      fsDeleteMeal,
      fsAddNewMeal,
      fsUpdateMeal,
      fsGetMealLabels,
      fsAddNewMealLabel,
      fsUpdateMealLabel,
      fsDeleteMealLabel,
      // fsUpdateAllMetaTags,
      // fsUpdateMealMetaTags,
      // fsRemoveTagFromAllMeals,
      // // ---- QR Menu ----
      fsConfirmCartOrder,
      fsUpdateScanLog,
      fsUpdateCart,
      fsRemoveMealFromCart,
      // fsOrdersSnapshot,
      // fsInitiateNewOrder,
      // // ---- Waiter ----
      fsGetStaffLogin,
      fsGetStaffInfo,
      // fsWaiterTablesSnapshot,
      fsUpdateOrderStatus,
      // fsCancelOrder,
      fsOrderIsPaid,
      fsAddNewStaff,
      fsGetStaffList,
      fsUpdateStaffInfo,
      fsDeleteStaff,
      // // ---- RTD ----
      // dataSnapshotListener,
      // docSnapshot,
      // // ---- NO SIGNED IN ----
      // fsGetAllMealsOFF,
      // fsSendEmail,
      // fsSendSMS,
    ]
  );

  return <AuthContext.Provider value={memoizedValue}>{children}</AuthContext.Provider>;
}
